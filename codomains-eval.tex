\section{Codomains Evaluation}
\label{sec:codomains-eval}


\subsection{Macro-benchmarks}

\parhead{Webserver}
%
I evaluate the request throughput and latency of a webserver, such as NGINX,
running in a standard Linux environment, and compare against a configuration of
the webserver running with codomains, where a separate domain isolates each
website's private TLS key.
%
I also compare the codomain version of the webserver to 
static partitioning schemes~\cite{eleos,glamdring,privtrans} that achieve
the same isolation.
%
When comparing to static partitioning schemes, I am interested not only in the
performance differences, but also the difference in the boundaries that
each scheme determines.
%
The benchmark affords multiple variants, such as investigating how codomains
scale with multiple tenants (multiple websites multiplexed by the same
webserver), how the system performs when the webserver itself contains
private data that must be cloaked from tenants, how well different server
models (such as multi-process vs. multi-threaded) interact with codomains, and
how host-codomains compare to enclave-codomains.


\parhead{Federated Data Analysis}


\parhead{Federated Learning}


\subsection{Micro-benchmarks}

With the micro-benchmarks, I am interested in isolating and measuring the cost
of each facet of codomains---thread migration, taint tracking, the DSM
protocol.
%
For such purposes, I envision developing a small set of multi-party programs
drawn from the literature, such as:

\begin{widelist}
\item \textbf{Timestamp signing server:} Returns a signature over the current
time to each client; I assume the server's key must be isolated from the
server's host.
%
\item \textbf{Richest protocol:} Computes the richest principal.
%
\item \textbf{GPS protocol:} For each participating principal,
computes the peer that is nearest to their location; each principal learns
their nearest neighbor without learning anyone's exact location.
%
\item \textbf{Auction protocol:} Computes the high bidder among a set of
participating principals, as well as the second-highest bid, which is revealed
to everyone; only the auction holder learns the winning bidder.
\end{widelist}

For the timestamp signing server, I am interested in how closely a
packet capture of the thread migration between codomains approximates
that of an alternative RPC-based implementation, such as keyless SSL\@?
%
In particular, how much traffic and how many round-trips does a codomain switch
incur, what is the purpose of each round-trip, and what is the corresponding
ratio of goodput to throughput?
%
Moreover, is each migration identical?


Closely related to the previous question, I seek to measure the latency of
migration and the related operations.
%
Direct overhead costs include network latency, while indirect costs include the
operations of checkpointing and restoring threads, as well as any TCP queuing
delays incurred by the source host while its thread is paused, waiting for
a return migration.

\subsection{Correctness}

I want to assert correctness of data cloaking and resource coherence.
%
For asserting correctness of data cloaking, I envision developing an external
program that dumps each process's memory and scans for a given byte string,
and running this program periodically and in tandem with the micro-benchmarks.
%
Similarly, asserting resource coherence may entail developing an external
manager that records a snapshot of the distributed system's global state, and
analyzes the state for consistency invariants.
%
Such a manager may also be useful in deadlock detection.
%
Finally, in order to test that codomains properly validate execution state when
restoring a thread, I imagine a set of fault-injection tests whereby one
codomain attempts to switch to another at an invalid state.
